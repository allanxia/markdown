数据库的复习是参照《数据库系统设计与实现》这本书复习的，这是本科时的教程，大致浏览了一遍，面试时碰到的数据库问题无外乎各种范式和查询语句，考的都不难。  

数据的逻辑组织是用户（或应用程序）所使用的数据结构形式。  
其物理组织是数据在物理存储设备上的结构形式。  

数据库的优点：  
1. 数据集成共享  
2. 数据冗余控制与一致性保证  
3. 数据独立  
4. 实施统一标准  
5. 统一安全，保密和完整性控制  


数据库的研究分成3个方面：　　


1. 数据库理论　　
2. 数据库管理系统　　
3. 数据库应用　　


> 数据定义语言（data definitaion language） DDL  
> 数据操纵语言（data manipulation language） DML  
> 数据查询语言（query language） QL  
> 数据控制语言（database control language） DBCL  

DBMS一般可以有三种数据存取方式：顺序，随机，索引。  

RDBMS3类完整性:  
1. 实体完整性  
2. 访问完整性  
3. 用户定义的完整性  


数据模型是用户描述数据的一种数学形式体系，作为一种数据库的数据模型。它包括三种基本工具：  
1. 一个描述数据，数据联系，数据语义学的概念及其符号表示系统；  
2. 一组用来处理这种数据的操作  
3. 一组关于这些数据（包括结构与操作）的约束  


关系模型有两条基本的完整性规则：  
1. 实体完整性： 任何关系的主关键字中的任何属性都不能有空值（NULL）  
2. 引用完整性：  若关系$R_1$ 包含了一个外来关键字$FK_1$，它是另一个关系$R_2$的主关键字$PK_2$,则$R_1$中的$FK_1$中的每一个值必须是等于$R_2$中某一元组的$PK_2$值，或者全为空白。


传统的集合运算：  
1. 并集（$\cup$）    
两个关系$R_1$ 和$R_2$ 的并行运算用“$\cup$” 来表示，它产生一个新的关系$R_3$ ，该$R_3$ 由关系$R_1$或$R_2$ 的所有不同元祖组成：  
$$R_1 \cup R_2=R_3=\{t | t \in R_1 \lor t \in R_2 \land\lnot(t \in R_1 \land t \in R_2)\}$$  
2. 差（-）  
两个关系$R_1$和$R_2$的差运算用“-”来表示，它产生一个新的关系$R_3$，该$R_3$由属于$R_1$但不属于$R_2$的元组组成，即
$$R_1-R_2=R_3=\{t|t \in R_1 \land t \notin R_2\}$$  
3.交（$\cap$）  
两个关系$R_1$和$R_2$的交运算用“$\cap$”来表示，它产生一个新的关系$R_3$，该$R_3$由既属于$R_1$又属于$R_2$的元组组成，即：  
$$R_1 \cap R_2 =\{t|t \in R_1 \land t \in R_2\}$$  
4. 笛卡尔积($\times$)  
设$R_1$为m元关系，$R_2$为n元关系，$R_1$和$R_2$的笛卡尔积运算用“$\times$”表示，它产生一个新关系$R_3$，该$R_3$由$R_1$和$R_2$的所有元组分别连接而成的m+n元组组成，其中前m个分量是$R_1$的一个元组，后n个分量为$R_2$的一个元组，即：  
$$R_1 \times R_2 =R_3 =\{t_1t_2 | t_1 \in R_1 \land t_2 \in R_2\}$$  

专门的关系运算：选择，投影，连接和除  
1. 选择（$\sigma$）
选择运算是从给定关系中选取满足指定条件的所有元组，表示为：  
$$\sigma_c(R)=\{t|t \in R \land C_{(t)}='T'\}$$
其中C是由给定关系R的属性名或列号，算术比较运算符($<$,$>$,$\leq$,$\geq$,$=$,$\not=$)和逻辑运算符($\lor$,$\land$,$\lnot$)组成的条件表达式。$C_{(t)}$表示关于元组t的条件表达式C，'T'为逻辑真。  
2.投影（$\pi$）
上述的$\sigma$运算是横向地选取指定关系中的某些元组，投影运算则纵向地选取指定关系中的某些指定的属性组成结果关系，且其中的属性排列顺序可以重新给定。结果中重复的元组要去掉，它表示为：  
$$\pi_{(A)}(R)=\{t[A]|t \in R\}$$
其中，A为R的一个属性名或列号集，t[A]表示由元组t相对于A指明的那些属性值组成的新元组。  
3.连接($\bowtie$)

 - 条件连接  
     条件连接运算就是将两个关系先做笛卡尔积，然后再针对给定的条件做选择运算。
     
 - 等值连接
     等值连接是条件连接为“=”号时的特例。
    
 - 自然连接
     自然连接就是等值连接在两个被笔记的属性相同时的特例，且其结果关系中重复的属性被去掉，此时，在表示中干脆去掉条件，简单表示为$R_1\bowtie R_2$。注意：自然连接与等值连接不一样，它要求必须有公共属性，其结果中公共属性只出现一次。

4.除($\div$)

**SQL的基本查询**格式为：

$$SELECT \quad A_1,A_2\ldots,A_k  \quad FROM  \quad R_1,R_2\ldots,R_j WHERE P$$
这里$R_1,R_2\ldots,R_j$是不同关系名的列表  
$A_1,A_2\ldots A_k$是要输出的关系属性  
$A_i$一般取$R.A$的形式  
P是由逻辑运算符(AND,OR和NOT)以及比较运算符（$<$,$=$,$\le$）等构成的谓词，这个查询等价于关系代数表达式：
$$\pi_{A_1,A_2\ldots A_k}(\sigma_p(R_1\times R_2 \times  \ldots \times R_j))$$

$[\times \times \times]$ 表示其中的成分可以任选，即可有可无  
$<\times \times \times>$表示其中的成分需要具体给出或递归地进一步说明 
$$\begin{vmatrix}
\times \times \times  \\
\times  \times \times   \\
\end{vmatrix}$$
表示其中并列成分可以也只能选择其一
$\{\times \times \times\}$表示其中的成可以重复任意次（0~n）次

基本关系的定义及变更

 1. 定义关系
 $CREATE \quad TABLE \quad <关系名> \quad (<属性定义>\{,<属性定义>\}) \quad [<其它参数>]$
 其中$<属性定义>$的格式为：
 $$<属性名> \quad \begin{vmatrix} 
CHAR(n) \\
NUMBER(n,m) \\
DATE \\
INTEGER \\
SMALLINT \\
FLOAT \\
LONG \\
\end{vmatrix} \quad [NOT  \quad NULL]
$$

2.撤销关系  
$DROP \quad TABLE \quad <关系名>$

3.修改关系模式  
$$ALTER  \quad TABLE \quad <关系名> \begin{vmatrix}
ADD \quad <属性定义> \\
DROP \quad <属性定义> \\
MODIFY \quad <属性定义>
\end{vmatrix}
 $$

4.视图是一种虚关系，它本身并不单独存在，而是当需要时由相关基本关系抽取相关数据组织而成，视图定义说明了如何进行这种数据抽取，其语句形式为：
$CREATE \quad VIEW \quad <视图名> \quad [(<属性名>\{,<属性名>\})] \quad as \quad <查询>$

5.撤销视图  
$DROP  \quad VIEW \quad <视图名>$

6.索引的建立  
建立索引的一般格式为：
$CREATE \quad [UNIQUE] \quad INDEX \quad <索引名> \quad ON \quad <关系名> \quad (<属性名>[<排序>]\{,<属性名>[<排序>]\})$
其中$<排序>$可以是ASC(升序)或DESC（降序），缺省则为ASC。

7.删除索引  
$DROP \quad INDEX \quad <索引名>$

**1.基本查询**    
1.   元条件简单查询   
元条件查询就是在指定范围内选取所有的元组，它有下列基本形式：  
1.   在SELECT子句中列出要查询的属性名  
$SELECT \quad  S\#,C\# \quad FROM \quad Enroll$
2.   SELECT子句的星号“*”
星号“*”表示FROM子句中所指定的所有关系属性都被选择  
$SELECT \quad * \quad FROM \quad Enroll $
3.   消除重复结果的查询  
$SELECT \quad DISTINCT \quad C\# \quad FROM \quad Enroll$  
4.  计算查询  
$SELECT \quad S\#,Sage+4 \quad FROM \quad Student$



**2. 条件查询**  
可以通过WHERE子句给出条件或谓词，从而查询满足满足给定条件的数据。  
关于条件查询，有下列几种典型的方式：  
1. WHERE子句中可以包括比较运算符$=$,$\lnot$,$!=$或者$<>$（不等于），$<$，$>$，$<=$，$>=$，布尔运算符AND，OR和NOT（与，或，非）；以及指明比较顺序的括号。   
2.SQL提供了一堆相当于比较操作的谓词$"BETWEEN \ldots AND \ldots"$或$NOT \quad BETWEEN \ldots AND \ldots$来指定属性值在某个区间内或外。  
3. 用谓词IN或NOT IN指明查找的属性值在或不在某列举的值集内  
4. 字符串匹配查询  
字符串匹配是WHERE子句中叫常见的条件之一，它以谓词LIKE来指明：   

> %：:代码任意长度（不可以为0）的任何字符  
> _：代表任意单个字符  
> [charlist]：字符列表中的任何单个字符  
> [$\lnot$charlist]或[!charlist]：不在字符列表中的任何单个字符  
> \：为转换标记  
> NOT LIKE：相反的语义  

5.空值查询  
SQL允许使用空值（NULL），它表示属性值的空缺，不是任何真正的值，故它不能茶语算术和比较运算，但可以作为查询谓词:
$SELECT \quad S\#,C\# FROM \quad Enroll \quad WHERE \quad Grade \quad IS \quad NULL$  
与IS NULL谓词相对的谓词是IS NOT NULL。  
6. 查询结果排序  
SQL提供用户以空值查询结果关系中元组顺序的手段，这就是ORDER　BY子句，它使查询结果的元组按指定属性（可以多个）值的升序（ASC）或降序（DESC）排列，缺省为升序。  


**3.使用聚集函数的查询**  
1. 聚集函数  
聚集函数就是以值集作为输入而产生单个值的函数，SQL提供了5种内在的聚集函数：
AVG(<属性名>)：求<属性名>指定的属性的平均值  
MIN(<属性名>)：求<属性名>指定的属性的最小值  
MAX(<属性名>)：求<属性名>指定的属性的最大值
SUM(<属性名>)：求<属性名>指定的属性的值汇总  
$$COUNT \quad (\begin{vmatrix}
* \\
<属性名> \\
\end{vmatrix}) \quad 元组计数 /<属性名>指定的属性值的个数（包括重复的）$$

2.消去重复  
有时在计算聚集函数前必须消去重复，为此，可以在聚集表达式中使用关键字DISTINCT。  
这里需要指出的是，SQL不允许DISTINCT与“*”一起使用，即COUNT (DISTINCT *)是错误的，此外，DISTINCT可以在AVG，MIN，MAX和SUM的表达式中使用。  

3.查询结果分组  
存在这样的情况，不仅是要求聚集函数作用于单个的元素集，而且有多组（每组有多个）元组，希望聚集函数同时作用于每一组，在SQL中，这可由GROUP BY子句来解决，它使每组有不同的函数值，而同一组有相同的函数值。
$SELECT \quad S\# ,AVG(Grade) \quad FROM \quad Enroll \quad GROUP \quad BY \quad S\#$

4.分组筛选  
有时，在上述分组后，不是要聚集函数作用于所有分组，而是希望它们作用于满足某些条件的那些组，HAVING子句就是为此而设计的。  
$SELECT \quad S\#,AVG(Grade) \quad FROM \quad Enroll \quad GROUP \quad BY \quad S\# \quad HAVING \quad AVG(Grade) >=85$  
在该例中，先以GROUP BY子句按S#进行分组，然后聚集函数AVG作用于每组(即每个学生)，最后再筛选出满足指定条件（即平均成绩大于等于85）的组作为结果。  
HAVING与WHERE不一样，两者的作用对象不同。后者是FROM关系中的各元组，前者是经GROUP BY形成的组（所以，HAVING必须与GROUP BY联用）。

**关系的连接**  
连接由“连接类型”和“连接条件”（或谓词）两部分组成，连接条件决定两个被连接的关系中哪些元组是匹配的，以及什么属性将出现在结果关系中；连接类型决定每个关系中不与另一个关系中任何元组匹配的那些元组如何处理。  

连接类型：  
> INNER　JOIN：内连接  
> LEFT OUTER JOIN：左外连接  
> RIGHT OUTER JOIN：右外连接  
> FULL OUTER JOIN：全外连接  

连接条件：  
> NATURAL  
> ON
> USING($A_1,A_2 \cdots A_n$)


对于外连接必须使用连接条件，内连接可以没有条件。此时就是笛卡尔积，在使用时，关键字NATURAL需要放在连接类型说明以前，而ON和USING则在其后。  

连接的类型说明是针对关系的，故它可以出现在查询中关系能出现的任何地方，典型的是FROM子句中，连接条件说明则是针对条件的，故而它能出现在查询中的条件所在之处，主要是WHERE子句中，当然也可以作为整个连接表达式的一部分出现在FROM子句中。  

1. 内连接表达式  
Student INNER JOIN Enroll On Student.S#  
就是一般的等值连接  
2. 左外连接表达式  
Student LEFT OUTER JOIN Enroll On Student.S#=Enroll.S#  
先计算自然连接的结果，然后将左边关系Student中每一个不与右关系Enroll中任何元组匹配的元组加入结果，其对应右关系的属性值填上NULL值。  
3. 右外连接与左外连接对称  
4. 自然内连接表达式  
Student NATURAL INNER JOIN Enroll  
就是一般的自然连接  
连接条件$USING(A_1,A_2 \cdots A_n)$ 类似于自然连接条件，只不过连接属性是某些公共属性$A_1,A_2 \cdots A_n$，而不是全部公共属性。$A_1,A_2 \cdots A_n$也只在结果中出现一次。  
5.全部外连接表达式  
Student FULL OUTER JOIN Enroll USING(S#)  


元组变量
> 有时查询要涉及统一关系的两个或多个元组，需要同一关系与自身的连接。即同一关系在FROM子句中出现多次，为了区分这种出现的不同，SQL允许为关系在FROM子句的每次出现定义一个别名，称为元组变量，以保留字AS（可以省略）标明。  


查询的并，交，差  
1. 并 UNION 会主动去掉结果中重复的元组  
2. 交 INTERSECT   
3. 差 EXCEPT  

eg:  
（SELECT S# FROM Student WHERE Dept='CS'） INTERSECT (SELECT S# FROM Enroll WHERE C#='450')  
上面这些操作的前提条件是各查询结果关系具有相同的属性集，使用时用括号括起来查询。

**数据库的变更**  
**数据插入**  
INSERT INTO <关系名> [(<属性名表>)] VALUES (<常量表>)   
插入数据的另一种格式是：  
INSERT INTO <关系名> [(<属性名表>)]  <子查询>  

**数据删除**  
DELETE FROM <关系名> [WHERE <条件表达式>]   

**数据修改**  
UPDATE <关系名> SET <属性名>=<表达式> {,<属性名>=<表达式>} [WHERE <条件表达式>]   


**数据控制**
数据控制包括安全性控制，完整性控制，事务控制和并发控制。  
**安全性控制**  
**授权**  
GRANT <权利表> ON <数据元素> TO <用户表> [WITH GRANT OPTION]  

**建权**  
CONNECT TO <服务器名> AS <连接名> AUTHORIZATION <用户名和口令>  

**收权**  
REVOKE <权利表> ON <数据元素> FROM <用户表> [CASCADE|RESTRICT]  

**完整性控制**  
1. **关键字限制**  
UNIQUE 来说明候选关键字  
PRIMARY KEY说明主关键字  

2.**外来关键字限制**  
FOREIGN KEY(<属性>) REFERENCES <关系名>  

3.**属性值限制**   
1.  NOT NULL  
2.  基于属性的CHECK限制  
3.  值域限制  

根据数据库的功能，可以在数据库设计器中创建三种索引：  
**唯一索引**是不允许其中任何两行有相同索引值的索引。  

**主键索引**：在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每一个值都唯一，当在查询中使用主键索引时，还允许对数据的快速访问。  

**聚集索引**：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同，一个表只能包含一个聚集索引。  


> 一个事务是一个通过存取共享数据库以实现某一个应用功能的活动集合。  


事务的ACID特性：  
1. 原子性  
2. 一致性  
3. 隔离性  
4. 永久性  


锁的类型：  
1. 共享锁：又称读锁  
2. 排它锁:又称写锁  


**数据库范式**：  
1. 第一范式  
第一范式指数据库表的每一列都是不可分割的基本数据项。  
2.第二范式  
在满足第一范式的基础上，实体的属性完全依赖于主关键字，所谓完全依赖是指不存在仅依赖主关键字一部分的属性(即不能有组合关键字)。  
3.第三范式  
在满足第二范式的继承上，表中不包含已经在其它表中已包含的非主关键字。  

更加学术点的说法：  
1. 若一个关系（模式）的所有属性域都是原子的，则称该关系满足第一范式；  
2. 如果一个关系式1NF的，且每一非主属性都完全函数依赖于每一个关键字，则称该关系式第二范式的，记为2NF；  
3. 若一个关系式2NF的，且不存在非主属性间的函数依赖，则说它是第三范式的，记为3NF


 

 
 




