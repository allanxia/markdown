


所谓**仿函数**，就是使用起来像函数一样的东西，如果你针对某个class进行operator()重载，它就成为一个仿函数，至于要成为一个可配接的仿函数，它还需要一些额外的努力。  

**迭代器**是一种行为类似于指针的对象。  

在C++中，函数如果要返回**左值**，都是以**by reference**。  

迭代器相应型别：  
1. value type  
2. different type   
3. reference type   
4. point type  
5. iterator_category  

![](http://i.imgur.com/s0ANiIE.png)

**vector**是一种单向开口的连续线性空间，**deque**则是一种双向开口的连续线性空间。所谓双向开口，意思可以在头尾两端分别做元素的插入和删除操作。


**deque**和**vector**的最大差异，一是在于deque允许常数时间内对头端元素进行插入或移除操作；二是在于deque没有所谓的容量capacity概念，因为它是动态以分段连续空间组合而成的，随时可以增加一段新的空间并链接起来。  

**list**不仅是一个双向链表，而且还是一个环状双向链表。  


![](http://i.imgur.com/Ajl1DxP.png)


**RB-tree**不仅是一个二叉搜索树，而且必须满足以下规则：  
1. 每个节点不是红色就是黑色  
2. 根节点为黑色  
3. 如果节点为红，其子节点必须为黑  
4. 任一节点至NULL(树尾端)的任何路径，所含之黑节点数必须相同  



无向边：若顶点$v_i$到$v_j$之间的边没有方向，则称这条边为无向边。用无序偶对$(v_i,v_j)$表示，如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图**。  


有向边：若从顶点$v_i$到$v_j$的边有方向，则称这条边为有向边，也称为弧，如果图中任意两点顶点之间的边都是有向边，则称该图是**有向图**。  


在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为**简单图**。  

在无向图中，如果任意两个顶点之间都存在边，则称该图为**无向完全图**。  

在有向图中，如果任意两个顶点都存在方向互为相反的两条弧，则称该图为**有向完全图**。  

有很少条边或弧的图称为**稀疏图**，反之称为**稠密图**。  

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数字叫做**权**，带权的图通常叫做**网**。  

图中顶点间存在路径，两顶点存在路径说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径，若任意两顶点都是连通的，则图就是**连通图**，有向则称**强连通图**，图中有子图，若子图极大连通则就是**连通分量**，有向的则称**强连通分量**。  


无向图中连通且n个顶点n-1条边叫做生成树，有向图中一顶点入度为0其余顶点入度为1的叫做有向树，一个有向图由若干棵有向树构成**生成树森林**。  

数据结构的最终目的是提高数据的处理速度，**索引**就是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程。一个索引由若干个索引项组成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置。  

**索引**按照结构可以分成**线性索引**，**树形索引**，和**多级索引**。  

- **线性索引**就是将索引项集合组织为线性结构，也称为索引表。包括**稠密索引**，**分块索引**和**倒排索引**。  
- 对于稠密索引这个索引表，索引项一定是按照关建码有序的排序。  
- **分块索引**：对数据集进行分块，是其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。分块有序是把数据集的记录分成若干块，并且这些块需要满足两个条件：块内无序，块间有序。  
- **倒排索引**：由属性来确定记录的位置。  


加载程序将符号的虚拟地址写入到可执行文件模块的导入段，这使的在程序引用导入的符号时，实际引用的是正确的内存地址。  

一个标准的线程由线程ID，当前指令指针（PC），寄存器集合和堆栈组成，通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段，数据段，堆等）及一些进程级的资源（如打开的文件，信号等）。  

**可重入与线程安全**：  
一个函数被重入，表示这个函数没有被执行完成，由于外部因素或内部调用，又一次进入该函数执行，一个函数要被重入，只有两种情况：  
1. 多个线程同时执行这个函数  
2. 函数自身调用自身   

一个函数被称为**可重入的**，表明该函数被重入之后不会产生任何不良后果。  

一个函数要成为**可重入的**，必须具有如下特点：  
1. 不使用任何（局部）静态或全局非const变量  
2. 不返回任何（局部）静态或全局非const变量的指针  
3. 仅依赖于调用方提供的参数  
4. 不依赖任何单个资源的锁  
5. 不调用任何不可重入的函数  

**volatile关键字**防止编译器过度优化：  
1. 阻止编译器为了提高速度将一个变量缓存到寄存器而不写回  
2. 防止编译器调整操作volatile变量的指令顺序  

```
  
gcc -E 预处理  
gcc -S 生成汇编文件  
gcc -c 编译生成.o文件  

```

模块之间如何组合的问题可以归结为模块之间如何进行通信的问题，最常见的C/C++模块之间的通信方式有两种：一种是**模块之间的函数调用** ，另一种是**模块之间的变量访问** 。函数调用须知道目标函数的地址，变量访问也需要知道目标变量的地址，所以这两种方式都归结为一种方式，那就是模块间符号的引用。模块间依靠**符号** 来通信。

组装模块的过程就是**链接**，链接的主要内容就是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正确地链接。  

**链接过程**主要包括**地址与空间分配** ，**符号决议与重定位**。  

地址修正的过程叫做**重定位**。每个要被修正的地方叫做一个重定位入口，重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”。使它们指向正确的地址。  

**目标文件**从结构上来讲，它是已编译后的可执行文件格式，只是还没有进过链接的过程，其中可能有些符号或有些地址还没有被调整，其实它本身就是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。  

```
  
ELF Header  
.text  
.data  
.bss  
...  
Section header table  段表  
string tables  字符串表  
symbol tables  符号表  



```
 
**段表**就是保持段基本属性的数据结构，段表是ELF文件中除了文件头以外最重要的数据结构，它描述了ELF的各个段的信息，比如每个段的短名，段的长度，在文件中的偏移，读写权限及段的其它属性。也就是说，ELF文件的段结构就是由段表来决定的，编译器，链接器和装载器都是依靠段表来定位和访问各个段的属性的。   


一个**重定位表**同时是ELF的一个段，链接器在处理目标文件时，须要对目标文件中的某些部位进行重定位。即代码段和数据段中哪些对绝对地址引用的位置，这些重定位的信息都记录在ELF文件的重定位表里。  

在链接中，我们将函数和变量统称为**符号**，函数名或变量名就是**符号表**。  

链接器一般都是采用**两步链接** 的方法，也就是说整个链接过程分成两步：  
1. 第一步：**空间与地址分配** ，扫描所有的输入文件，获得它们的各个段的长度，属性和位置，并且将输入目标文件中的符号表中的所有符号定义和符号引用搜集起来，统一放到一个全局符号表中，这一步中，链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算输出文件中各个段合并后的长度和位置，并建立映射关系。  
2. 第二步：**符号解析与重定位** ，使用上面第一步收集到的所有信息读取输入文件段的数据，重定位信息，并且进行符号解析与重定位，调整代码中的地址等。  


**符号地址** 的确定：  
当前一步完成后，链接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对地址是固定的，只不过链接器必须要为每个符号加上一个偏移量，使得他们能够调整到正确的虚拟地址。  

在完成**空间和地址的分配**步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态连接的核心内容。  

每一个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF文件中的一个段，所以其实重定位表也可以叫做**重定位段**。  

**重定位** 过程也伴随着符号的解析过程，每个目标文件都可以定义一些符号，也可能引用到定义在其它目标文件的符号。重定位的过程，每个重定位的入口都是对一个符号的引用。那么当链接器要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址，这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表。找到相应的符号后进行重定位。  




